"""PostgreSQL PgCrypto Hashing Backend."""

from typing import TYPE_CHECKING, Union

from sqlalchemy import func, type_coerce
from sqlalchemy.types import String

from advanced_alchemy.types.password_hash.base import HashingBackend

if TYPE_CHECKING:
    from sqlalchemy.sql.elements import ColumnElement
    from sqlalchemy.sql.functions import FunctionElement


class PgCryptoHasher(HashingBackend):
    """Hashing backend using PostgreSQL's pgcrypto extension.

    Requires the pgcrypto extension to be enabled in the PostgreSQL database.
    Hashing and verification are performed directly by the database using SQL functions.
    """

    def __init__(self, algorithm: str = "bf") -> None:
        """Initialize PgCryptoBackend.

        Args:
            algorithm: The algorithm to use with gen_salt (e.g., 'md5', 'bf').
                       'bf' (Blowfish) is recommended for passwords.
        """
        self.algorithm = algorithm

    def hash(self, value: "Union[str, bytes]") -> "FunctionElement[str]":
        """Generate a SQL function call to hash the password using pgcrypto.

        Args:
            value: The plain text password.

        Returns:
            A SQLAlchemy FunctionElement representing `crypt(password, gen_salt(algorithm))`.
        """
        return func.crypt(value, func.gen_salt(self.algorithm))

    def verify(self, plain: "Union[str, bytes]", hashed: "Union[str, bytes]") -> bool:
        """Verification must be done via SQL comparison.

        This method raises NotImplementedError because pgcrypto verification
        requires comparing the stored hash in the database with the result of
        `crypt(plain_password, stored_hash)`. Use the
        `get_sql_comparison_expression` method to generate the required
        SQLAlchemy expression for a WHERE clause.

        Args:
            plain: The plain text password.
            hashed: The stored hash (unused in this context).

        Raises:
            NotImplementedError: Always raised.
        """
        msg = "PgCryptoBackend requires verification via SQL comparison. Use `get_sql_comparison_expression`."
        raise NotImplementedError(msg)

    @staticmethod
    def identify(hashed: "Union[str, bytes]") -> bool:
        """Attempt to identify if a hash was generated by pgcrypto.

        Note: This is a very basic check. PgCrypto hashes (especially Blowfish)
        often start with '$2a$' or '$2b$', but this isn't guaranteed or exclusive.
        Relying on this for critical logic is discouraged. Assumes any value
        retrieved from a column using this backend is potentially valid.

        Args:
            hashed: The potential hash string.

        Returns:
            True if the hash might be a pgcrypto hash, False otherwise.
        """
        # Basic check for Blowfish prefix, adjust if using other algorithms frequently
        return isinstance(hashed, str) and (
            hashed.startswith(("$2a$", "$2b$")) or len(hashed) > 10  # noqa: PLR2004
        )  # Add a length check as a fallback

    @staticmethod
    def get_sql_comparison_expression(
        db_column: "ColumnElement[str]",
        plain: str,
    ) -> "ColumnElement[bool]":
        """Generate the SQLAlchemy expression for password verification in SQL.


        Args:
            db_column: The SQLAlchemy ColumnElement representing the password hash column.
            plain: The plain text password provided for verification.

        Returns:
            A SQLAlchemy BinaryExpression suitable for a WHERE clause.
        """
        # Coerce the column to String to ensure correct comparison behavior if it's within the PasswordHash type
        local_pw_expr = type_coerce(db_column, String)
        return local_pw_expr == func.crypt(plain, local_pw_expr)
